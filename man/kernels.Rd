% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernels.R
\name{kernels}
\alias{kernels}
\alias{fmcmc_kernel}
\alias{fmcmc-kernel}
\alias{kernel_new}
\alias{print.fmcmc_kernel}
\alias{kernel_normal}
\alias{kernel_reflective}
\title{Various kernel functions for MCMC}
\usage{
kernel_new(proposal, logratio, ...)

\method{print}{fmcmc_kernel}(x, ...)

kernel_normal(mean = 0, scale = 1)

kernel_reflective(scale = 1, lb = -.Machine$double.xmax,
  ub = .Machine$double.xmax, fixed = FALSE)
}
\arguments{
\item{proposal}{Function. The function receives a single argument, an environment.
This function is later called in \link{MCMC} to propose changes in the chain based
on the current state. The function must return a vector of length equal
to the number of parameters in the model.}

\item{logratio}{Function. This function receives a single argument, an environment.
This function is called after a new state has been proposed, and is used to
compute the log of the hastings ratio.}

\item{...}{In the case of \code{kernel_new}, further arguments to be stored with
the kernel.}

\item{x}{An object of class \code{fmcmc_kernel}.}

\item{mean, scale}{Either a numeric vector or a scalar. Proposal scale.}

\item{lb, ub}{Either a numeric vector or a scalar. Lower and upper bounds for
bounded kernels (currently the \code{kernel_reflective} only).}

\item{fixed}{Logical scalar or vector. When \code{TRUE} fixes the corresponding
parameter, avoiding new proposals.}
}
\description{
Various kernel functions for MCMC
}
\details{
The function \code{kernel_new} is a helper function that allows creating
\code{fmcmc_kernel} which is used with the \code{MCMC} function.

The \code{kernel_normal} function provides the cannonical normal kernel
with symmetric transition probabilities.

The \code{kernel_reflective} implements the normal kernel with reflective
boundaries. Lower and upper bounds are treated using reflecting boundaries, this is,
if the proposed \eqn{\theta'} is greater than the \code{ub}, then \eqn{\theta' - ub}
is substracted from \eqn{ub}. At the same time, if it is less than \code{lb}, then
\eqn{lb - \theta'} is added to \code{lb} iterating until \eqn{\theta} is within
\code{[lb, ub]}.

In this case, the transition probability is symmetric (just like the normal
kernel).
}
\examples{
\dontrun{
# Example creating a multivariate normal kernel using the mvtnorm R package
library(mvtnorm)

# Define your Sigma
sigma <- ...

# Create the kernel
mvn_kernel <- kernel_new(
  proposal = function(env) {
  env$theta0 + as.vector(mvtnorm::rmvnorm(1, mean = 0, sigma = sigma, ...))
  },
  logratio = function(env) {
    env$f1 - env$f0 +
      log(mvtnorm::pmvnorm(upper = env$theta0 - env$theta1)) -
      log(mvtnorm::pmvnorm(upper = env$theta1 - env$theta0))
  },
  sigma = sigma
)

}
}
